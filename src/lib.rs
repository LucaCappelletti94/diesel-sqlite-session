#![doc = include_str!("../README.md")]
#![warn(clippy::all, clippy::pedantic, clippy::undocumented_unsafe_blocks)]
#![allow(clippy::module_name_repetitions)]

mod apply;
mod errors;
mod ffi;
#[cfg(all(
    feature = "mobile-smoke",
    not(all(target_family = "wasm", target_os = "unknown"))
))]
mod mobile_smoke;
mod session;

pub use errors::{ApplyError, ConflictAction, ConflictType, SessionError, SqliteErrorCode};
pub use session::Session;

use diesel::SqliteConnection;

/// Extension trait adding session capabilities to `SqliteConnection`.
///
/// This trait provides an idiomatic Rust API for creating sessions and applying
/// changesets/patchsets to `SQLite` connections.
///
/// # Example
///
/// ```no_run
/// use diesel::prelude::*;
/// use diesel_sqlite_session::{SqliteSessionExt, ConflictAction};
///
/// diesel::table! {
///     users (id) {
///         id -> Integer,
///         name -> Text,
///     }
/// }
///
/// let mut conn = SqliteConnection::establish(":memory:").unwrap();
///
/// // Create session using extension trait
/// let mut session = conn.create_session().unwrap();
///
/// // Type-safe table attachment
/// session.attach::<users::table>().unwrap();
///
/// // Or attach all tables
/// session.attach_all().unwrap();
///
/// // Or dynamic schema (runtime table name)
/// session.attach_by_name("dynamic_table").unwrap();
///
/// // Generate patchset and apply to another connection
/// let patchset = session.patchset().unwrap();
/// // replica.apply_patchset(&patchset, |_| ConflictAction::Abort).unwrap();
/// ```
pub trait SqliteSessionExt {
    /// Create a new session to track changes on this connection.
    ///
    /// # Errors
    ///
    /// Returns `SessionError::CreateFailed` if `SQLite` fails to create the session.
    fn create_session(&mut self) -> Result<Session, SessionError>;

    /// Apply a changeset to this connection.
    ///
    /// A changeset contains complete information about changes, including old
    /// values for conflict detection.
    ///
    /// # Arguments
    ///
    /// * `changeset` - The changeset bytes generated by `Session::changeset()`
    /// * `on_conflict` - A callback to handle conflicts; receives the conflict type
    ///   and returns the action to take
    ///
    /// # Errors
    ///
    /// Returns `ApplyError::ApplyFailed` if `SQLite` fails to apply the changeset.
    /// Returns `ApplyError::ConflictAborted` if the conflict handler returns `Abort`.
    /// Returns `ApplyError::ConflictHandlerPanicked` if the conflict handler panics.
    fn apply_changeset<F>(&mut self, changeset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction;

    /// Apply a patchset to this connection.
    ///
    /// A patchset contains only new values (not old values), making it smaller
    /// but with less precise conflict detection.
    ///
    /// # Arguments
    ///
    /// * `patchset` - The patchset bytes generated by `Session::patchset()`
    /// * `on_conflict` - A callback to handle conflicts; receives the conflict type
    ///   and returns the action to take
    ///
    /// # Errors
    ///
    /// Returns `ApplyError::ApplyFailed` if `SQLite` fails to apply the patchset.
    /// Returns `ApplyError::ConflictAborted` if the conflict handler returns `Abort`.
    /// Returns `ApplyError::ConflictHandlerPanicked` if the conflict handler panics.
    fn apply_patchset<F>(&mut self, patchset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction;
}

impl SqliteSessionExt for SqliteConnection {
    #[inline]
    fn create_session(&mut self) -> Result<Session, SessionError> {
        Session::new_internal(self)
    }

    #[inline]
    fn apply_changeset<F>(&mut self, changeset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction,
    {
        apply::apply_changeset(self, changeset, on_conflict)
    }

    #[inline]
    fn apply_patchset<F>(&mut self, patchset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction,
    {
        apply::apply_patchset(self, patchset, on_conflict)
    }
}
