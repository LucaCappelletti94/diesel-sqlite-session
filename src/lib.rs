#![doc = include_str!("../README.md")]
#![warn(clippy::all, clippy::pedantic)]
#![allow(clippy::module_name_repetitions)]

mod apply;
mod errors;
mod ffi;
mod session;

pub use errors::{ApplyError, ConflictAction, ConflictType, SessionError, SqliteErrorCode};
pub use session::Session;

use diesel::SqliteConnection;

/// Extension trait adding session capabilities to `SqliteConnection`.
///
/// This trait provides an idiomatic Rust API for creating sessions and applying
/// changesets/patchsets to `SQLite` connections.
///
/// # Example
///
/// ```no_run
/// use diesel::prelude::*;
/// use diesel_sqlite_session::{SqliteSessionExt, ConflictAction};
///
/// diesel::table! {
///     users (id) {
///         id -> Integer,
///         name -> Text,
///     }
/// }
///
/// let mut conn = SqliteConnection::establish(":memory:").unwrap();
///
/// // Create session using extension trait
/// let mut session = conn.create_session().unwrap();
///
/// // Type-safe table attachment
/// session.attach::<users::table>().unwrap();
///
/// // Or attach all tables
/// session.attach_all().unwrap();
///
/// // Or dynamic schema (runtime table name)
/// session.attach_by_name("dynamic_table").unwrap();
///
/// // Generate patchset and apply to another connection
/// let patchset = session.patchset().unwrap();
/// // replica.apply_patchset(&patchset, |_| ConflictAction::Abort).unwrap();
/// ```
pub trait SqliteSessionExt {
    /// Create a new session to track changes on this connection.
    ///
    /// # Errors
    ///
    /// Returns `SessionError::CreateFailed` if `SQLite` fails to create the session.
    fn create_session(&mut self) -> Result<Session, SessionError>;

    /// Apply a changeset to this connection.
    ///
    /// A changeset contains complete information about changes, including old
    /// values for conflict detection.
    ///
    /// # Arguments
    ///
    /// * `changeset` - The changeset bytes generated by `Session::changeset()`
    /// * `on_conflict` - A callback to handle conflicts; receives the conflict type
    ///   and returns the action to take
    ///
    /// # Errors
    ///
    /// Returns `ApplyError::ApplyFailed` if `SQLite` fails to apply the changeset.
    /// Returns `ApplyError::ConflictAborted` if the conflict handler returns `Abort`.
    fn apply_changeset<F>(&mut self, changeset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction;

    /// Apply a patchset to this connection.
    ///
    /// A patchset contains only new values (not old values), making it smaller
    /// but with less precise conflict detection.
    ///
    /// # Arguments
    ///
    /// * `patchset` - The patchset bytes generated by `Session::patchset()`
    /// * `on_conflict` - A callback to handle conflicts; receives the conflict type
    ///   and returns the action to take
    ///
    /// # Errors
    ///
    /// Returns `ApplyError::ApplyFailed` if `SQLite` fails to apply the patchset.
    /// Returns `ApplyError::ConflictAborted` if the conflict handler returns `Abort`.
    fn apply_patchset<F>(&mut self, patchset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction;
}

impl SqliteSessionExt for SqliteConnection {
    #[inline]
    fn create_session(&mut self) -> Result<Session, SessionError> {
        Session::new_internal(self)
    }

    #[inline]
    fn apply_changeset<F>(&mut self, changeset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction,
    {
        apply::apply_changeset(self, changeset, on_conflict)
    }

    #[inline]
    fn apply_patchset<F>(&mut self, patchset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction,
    {
        apply::apply_patchset(self, patchset, on_conflict)
    }
}

#[cfg(test)]
mod tests {
    use diesel::prelude::*;
    use diesel::sql_query;

    use super::*;

    diesel::table! {
        test (id) {
            id -> Integer,
            value -> Nullable<Text>,
        }
    }

    diesel::table! {
        users (id) {
            id -> Integer,
            name -> Nullable<Text>,
        }
    }

    diesel::table! {
        items (id) {
            id -> Integer,
            data -> Nullable<Text>,
        }
    }

    #[derive(Insertable)]
    #[diesel(table_name = test)]
    struct NewTest<'a> {
        id: i32,
        value: Option<&'a str>,
    }

    #[derive(Queryable, Selectable)]
    #[diesel(table_name = test)]
    #[allow(dead_code)]
    struct Test {
        id: i32,
        value: Option<String>,
    }

    #[derive(Insertable)]
    #[diesel(table_name = users)]
    struct NewUser<'a> {
        id: i32,
        name: Option<&'a str>,
    }

    #[derive(Insertable)]
    #[diesel(table_name = items)]
    struct NewItem<'a> {
        id: i32,
        data: Option<&'a str>,
    }

    #[test]
    fn test_session_creation() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        let session = conn.create_session();
        assert!(session.is_ok());
    }

    #[test]
    fn test_attach_table_type_safe() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        assert!(session.attach::<test::table>().is_ok());
    }

    #[test]
    fn test_attach_table_by_name() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        assert!(session.attach_by_name("test").is_ok());
    }

    #[test]
    fn test_attach_all_tables() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        let mut session = conn.create_session().unwrap();
        assert!(session.attach_all().is_ok());
    }

    #[test]
    fn test_empty_session() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        assert!(session.is_empty());
    }

    #[test]
    fn test_changeset_generation() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("hello"),
            })
            .execute(&mut conn)
            .unwrap();

        assert!(!session.is_empty());

        let changeset = session.changeset().unwrap();
        assert!(!changeset.is_empty());
    }

    #[test]
    fn test_patchset_generation() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("hello"),
            })
            .execute(&mut conn)
            .unwrap();

        let patchset = session.patchset().unwrap();
        assert!(!patchset.is_empty());
    }

    #[test]
    fn test_enable_disable() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        // Disable tracking
        session.set_enabled(false);

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("hello"),
            })
            .execute(&mut conn)
            .unwrap();

        // Should be empty since tracking was disabled
        assert!(session.is_empty());

        // Re-enable tracking
        session.set_enabled(true);

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 2,
                value: Some("world"),
            })
            .execute(&mut conn)
            .unwrap();

        // Now should have changes
        assert!(!session.is_empty());
    }

    #[test]
    fn test_apply_patchset() {
        // Source connection
        let mut source = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
            .execute(&mut source)
            .unwrap();

        let mut session = source.create_session().unwrap();
        session.attach::<users::table>().unwrap();

        diesel::insert_into(users::table)
            .values(&[
                NewUser {
                    id: 1,
                    name: Some("Alice"),
                },
                NewUser {
                    id: 2,
                    name: Some("Bob"),
                },
            ])
            .execute(&mut source)
            .unwrap();

        let patchset = session.patchset().unwrap();

        // Replica connection
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
            .execute(&mut replica)
            .unwrap();

        replica
            .apply_patchset(&patchset, |_| ConflictAction::Abort)
            .unwrap();

        // Verify data was applied
        let count = users::table
            .count()
            .get_result::<i64>(&mut replica)
            .unwrap();
        assert_eq!(count, 2);
    }

    #[test]
    fn test_apply_changeset() {
        // Source connection
        let mut source = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE items (id INTEGER PRIMARY KEY, data TEXT)")
            .execute(&mut source)
            .unwrap();

        let mut session = source.create_session().unwrap();
        session.attach::<items::table>().unwrap();

        diesel::insert_into(items::table)
            .values(NewItem {
                id: 1,
                data: Some("item1"),
            })
            .execute(&mut source)
            .unwrap();

        let changeset = session.changeset().unwrap();

        // Replica connection
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE items (id INTEGER PRIMARY KEY, data TEXT)")
            .execute(&mut replica)
            .unwrap();

        replica
            .apply_changeset(&changeset, |_| ConflictAction::Abort)
            .unwrap();

        let count = items::table
            .count()
            .get_result::<i64>(&mut replica)
            .unwrap();
        assert_eq!(count, 1);
    }

    #[test]
    fn test_conflict_handling_omit() {
        // Source connection
        let mut source = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut source)
            .unwrap();

        let mut session = source.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("source"),
            })
            .execute(&mut source)
            .unwrap();

        let patchset = session.patchset().unwrap();

        // Replica with existing conflicting row
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut replica)
            .unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("replica"),
            })
            .execute(&mut replica)
            .unwrap();

        // Use Omit to skip conflicts
        replica
            .apply_patchset(&patchset, |_| ConflictAction::Omit)
            .unwrap();

        // Original value should be preserved
        let result: Test = test::table
            .filter(test::id.eq(1))
            .select(Test::as_select())
            .first(&mut replica)
            .unwrap();
        assert_eq!(result.value.as_deref(), Some("replica"));
    }

    #[test]
    fn test_conflict_handling_replace() {
        // Source connection
        let mut source = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut source)
            .unwrap();

        let mut session = source.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("source"),
            })
            .execute(&mut source)
            .unwrap();

        let patchset = session.patchset().unwrap();

        // Replica with existing conflicting row
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut replica)
            .unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("replica"),
            })
            .execute(&mut replica)
            .unwrap();

        // Use Replace to overwrite conflicts
        replica
            .apply_patchset(&patchset, |_| ConflictAction::Replace)
            .unwrap();

        // Value should be replaced
        let result: Test = test::table
            .filter(test::id.eq(1))
            .select(Test::as_select())
            .first(&mut replica)
            .unwrap();
        assert_eq!(result.value.as_deref(), Some("source"));
    }

    #[test]
    fn test_empty_changeset_apply() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();

        // Applying empty changeset should succeed
        conn.apply_changeset(&[], |_| ConflictAction::Abort)
            .unwrap();
        conn.apply_patchset(&[], |_| ConflictAction::Abort).unwrap();
    }

    #[test]
    fn test_update_tracking() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("original"),
            })
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        diesel::update(test::table.filter(test::id.eq(1)))
            .set(test::value.eq("updated"))
            .execute(&mut conn)
            .unwrap();

        assert!(!session.is_empty());

        let patchset = session.patchset().unwrap();
        assert!(!patchset.is_empty());

        // Apply to replica with original state
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut replica)
            .unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("original"),
            })
            .execute(&mut replica)
            .unwrap();

        replica
            .apply_patchset(&patchset, |_| ConflictAction::Abort)
            .unwrap();

        let result: Test = test::table
            .filter(test::id.eq(1))
            .select(Test::as_select())
            .first(&mut replica)
            .unwrap();
        assert_eq!(result.value.as_deref(), Some("updated"));
    }

    #[test]
    fn test_delete_tracking() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("to_delete"),
            })
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        diesel::delete(test::table.filter(test::id.eq(1)))
            .execute(&mut conn)
            .unwrap();

        assert!(!session.is_empty());

        let patchset = session.patchset().unwrap();

        // Apply to replica with the row
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut replica)
            .unwrap();

        diesel::insert_into(test::table)
            .values(NewTest {
                id: 1,
                value: Some("to_delete"),
            })
            .execute(&mut replica)
            .unwrap();

        replica
            .apply_patchset(&patchset, |_| ConflictAction::Abort)
            .unwrap();

        let count = test::table.count().get_result::<i64>(&mut replica).unwrap();
        assert_eq!(count, 0);
    }
}
