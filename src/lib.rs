#![doc = include_str!("../README.md")]
#![warn(clippy::all, clippy::pedantic)]
#![allow(clippy::module_name_repetitions)]

mod apply;
mod errors;
mod ffi;
mod session;

pub use errors::{ApplyError, ConflictAction, ConflictType, SessionError};
pub use session::Session;

use diesel::SqliteConnection;

/// Extension trait adding session capabilities to `SqliteConnection`.
///
/// This trait provides an idiomatic Rust API for creating sessions and applying
/// changesets/patchsets to `SQLite` connections.
///
/// # Example
///
/// ```no_run
/// use diesel::prelude::*;
/// use diesel_sqlite_session::{SqliteSessionExt, ConflictAction};
///
/// diesel::table! {
///     users (id) {
///         id -> Integer,
///         name -> Text,
///     }
/// }
///
/// let mut conn = SqliteConnection::establish(":memory:").unwrap();
///
/// // Create session using extension trait
/// let mut session = conn.create_session().unwrap();
///
/// // Type-safe table attachment
/// session.attach::<users::table>().unwrap();
///
/// // Or attach all tables
/// session.attach_all().unwrap();
///
/// // Or dynamic schema (runtime table name)
/// session.attach_by_name("dynamic_table").unwrap();
///
/// // Generate patchset and apply to another connection
/// let patchset = session.patchset().unwrap();
/// // replica.apply_patchset(&patchset, |_| ConflictAction::Abort).unwrap();
/// ```
pub trait SqliteSessionExt {
    /// Create a new session to track changes on this connection.
    ///
    /// # Errors
    ///
    /// Returns `SessionError::CreateFailed` if `SQLite` fails to create the session.
    fn create_session(&mut self) -> Result<Session, SessionError>;

    /// Apply a changeset to this connection.
    ///
    /// A changeset contains complete information about changes, including old
    /// values for conflict detection.
    ///
    /// # Arguments
    ///
    /// * `changeset` - The changeset bytes generated by `Session::changeset()`
    /// * `on_conflict` - A callback to handle conflicts; receives the conflict type
    ///   and returns the action to take
    ///
    /// # Errors
    ///
    /// Returns `ApplyError::ApplyFailed` if `SQLite` fails to apply the changeset.
    /// Returns `ApplyError::ConflictAborted` if the conflict handler returns `Abort`.
    fn apply_changeset<F>(&mut self, changeset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction;

    /// Apply a patchset to this connection.
    ///
    /// A patchset contains only new values (not old values), making it smaller
    /// but with less precise conflict detection.
    ///
    /// # Arguments
    ///
    /// * `patchset` - The patchset bytes generated by `Session::patchset()`
    /// * `on_conflict` - A callback to handle conflicts; receives the conflict type
    ///   and returns the action to take
    ///
    /// # Errors
    ///
    /// Returns `ApplyError::ApplyFailed` if `SQLite` fails to apply the patchset.
    /// Returns `ApplyError::ConflictAborted` if the conflict handler returns `Abort`.
    fn apply_patchset<F>(&mut self, patchset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction;
}

impl SqliteSessionExt for SqliteConnection {
    #[inline]
    fn create_session(&mut self) -> Result<Session, SessionError> {
        Session::new_internal(self)
    }

    #[inline]
    fn apply_changeset<F>(&mut self, changeset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction,
    {
        apply::apply_changeset(self, changeset, on_conflict)
    }

    #[inline]
    fn apply_patchset<F>(&mut self, patchset: &[u8], on_conflict: F) -> Result<(), ApplyError>
    where
        F: Fn(ConflictType) -> ConflictAction,
    {
        apply::apply_patchset(self, patchset, on_conflict)
    }
}

#[cfg(test)]
mod tests {
    use diesel::prelude::*;
    use diesel::sql_query;

    use super::*;

    diesel::table! {
        test (id) {
            id -> Integer,
            value -> Nullable<Text>,
        }
    }

    diesel::table! {
        users (id) {
            id -> Integer,
            name -> Nullable<Text>,
        }
    }

    diesel::table! {
        items (id) {
            id -> Integer,
            data -> Nullable<Text>,
        }
    }

    #[test]
    fn test_session_creation() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        let session = conn.create_session();
        assert!(session.is_ok());
    }

    #[test]
    fn test_attach_table_type_safe() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        assert!(session.attach::<test::table>().is_ok());
    }

    #[test]
    fn test_attach_table_by_name() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        assert!(session.attach_by_name("test").is_ok());
    }

    #[test]
    fn test_attach_all_tables() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        let mut session = conn.create_session().unwrap();
        assert!(session.attach_all().is_ok());
    }

    #[test]
    fn test_empty_session() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        assert!(session.is_empty());
    }

    #[test]
    fn test_changeset_generation() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        sql_query("INSERT INTO test (id, value) VALUES (1, 'hello')")
            .execute(&mut conn)
            .unwrap();

        assert!(!session.is_empty());

        let changeset = session.changeset().unwrap();
        assert!(!changeset.is_empty());
    }

    #[test]
    fn test_patchset_generation() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        sql_query("INSERT INTO test (id, value) VALUES (1, 'hello')")
            .execute(&mut conn)
            .unwrap();

        let patchset = session.patchset().unwrap();
        assert!(!patchset.is_empty());
    }

    #[test]
    fn test_enable_disable() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, value TEXT)")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach::<test::table>().unwrap();

        // Disable tracking
        session.set_enabled(false);

        sql_query("INSERT INTO test (id, value) VALUES (1, 'hello')")
            .execute(&mut conn)
            .unwrap();

        // Should be empty since tracking was disabled
        assert!(session.is_empty());

        // Re-enable tracking
        session.set_enabled(true);

        sql_query("INSERT INTO test (id, value) VALUES (2, 'world')")
            .execute(&mut conn)
            .unwrap();

        // Now should have changes
        assert!(!session.is_empty());
    }

    #[test]
    fn test_apply_patchset() {
        // Source connection
        let mut source = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
            .execute(&mut source)
            .unwrap();

        let mut session = source.create_session().unwrap();
        session.attach::<users::table>().unwrap();

        sql_query("INSERT INTO users (id, name) VALUES (1, 'Alice')")
            .execute(&mut source)
            .unwrap();
        sql_query("INSERT INTO users (id, name) VALUES (2, 'Bob')")
            .execute(&mut source)
            .unwrap();

        let patchset = session.patchset().unwrap();

        // Replica connection
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE users (id INTEGER PRIMARY KEY, name TEXT)")
            .execute(&mut replica)
            .unwrap();

        replica
            .apply_patchset(&patchset, |_| ConflictAction::Abort)
            .unwrap();

        // Verify data was applied
        let count: i64 =
            diesel::dsl::sql::<diesel::sql_types::BigInt>("SELECT COUNT(*) FROM users")
                .get_result(&mut replica)
                .unwrap();
        assert_eq!(count, 2);
    }

    #[test]
    fn test_apply_changeset() {
        // Source connection
        let mut source = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE items (id INTEGER PRIMARY KEY, data TEXT)")
            .execute(&mut source)
            .unwrap();

        let mut session = source.create_session().unwrap();
        session.attach::<items::table>().unwrap();

        sql_query("INSERT INTO items (id, data) VALUES (1, 'item1')")
            .execute(&mut source)
            .unwrap();

        let changeset = session.changeset().unwrap();

        // Replica connection
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE items (id INTEGER PRIMARY KEY, data TEXT)")
            .execute(&mut replica)
            .unwrap();

        replica
            .apply_changeset(&changeset, |_| ConflictAction::Abort)
            .unwrap();

        let count: i64 =
            diesel::dsl::sql::<diesel::sql_types::BigInt>("SELECT COUNT(*) FROM items")
                .get_result(&mut replica)
                .unwrap();
        assert_eq!(count, 1);
    }

    #[test]
    fn test_conflict_handling_omit() {
        // Source connection
        let mut source = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, val TEXT)")
            .execute(&mut source)
            .unwrap();

        let mut session = source.create_session().unwrap();
        session.attach_by_name("test").unwrap();

        sql_query("INSERT INTO test (id, val) VALUES (1, 'source')")
            .execute(&mut source)
            .unwrap();

        let patchset = session.patchset().unwrap();

        // Replica with existing conflicting row
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, val TEXT)")
            .execute(&mut replica)
            .unwrap();
        sql_query("INSERT INTO test (id, val) VALUES (1, 'replica')")
            .execute(&mut replica)
            .unwrap();

        // Use Omit to skip conflicts
        replica
            .apply_patchset(&patchset, |_| ConflictAction::Omit)
            .unwrap();

        // Original value should be preserved
        let val: String =
            diesel::dsl::sql::<diesel::sql_types::Text>("SELECT val FROM test WHERE id = 1")
                .get_result(&mut replica)
                .unwrap();
        assert_eq!(val, "replica");
    }

    #[test]
    fn test_conflict_handling_replace() {
        // Source connection
        let mut source = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, val TEXT)")
            .execute(&mut source)
            .unwrap();

        let mut session = source.create_session().unwrap();
        session.attach_by_name("test").unwrap();

        sql_query("INSERT INTO test (id, val) VALUES (1, 'source')")
            .execute(&mut source)
            .unwrap();

        let patchset = session.patchset().unwrap();

        // Replica with existing conflicting row
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, val TEXT)")
            .execute(&mut replica)
            .unwrap();
        sql_query("INSERT INTO test (id, val) VALUES (1, 'replica')")
            .execute(&mut replica)
            .unwrap();

        // Use Replace to overwrite conflicts
        replica
            .apply_patchset(&patchset, |_| ConflictAction::Replace)
            .unwrap();

        // Value should be replaced
        let val: String =
            diesel::dsl::sql::<diesel::sql_types::Text>("SELECT val FROM test WHERE id = 1")
                .get_result(&mut replica)
                .unwrap();
        assert_eq!(val, "source");
    }

    #[test]
    fn test_empty_changeset_apply() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();

        // Applying empty changeset should succeed
        conn.apply_changeset(&[], |_| ConflictAction::Abort)
            .unwrap();
        conn.apply_patchset(&[], |_| ConflictAction::Abort).unwrap();
    }

    #[test]
    fn test_update_tracking() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, val TEXT)")
            .execute(&mut conn)
            .unwrap();
        sql_query("INSERT INTO test (id, val) VALUES (1, 'original')")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach_by_name("test").unwrap();

        sql_query("UPDATE test SET val = 'updated' WHERE id = 1")
            .execute(&mut conn)
            .unwrap();

        assert!(!session.is_empty());

        let patchset = session.patchset().unwrap();
        assert!(!patchset.is_empty());

        // Apply to replica with original state
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, val TEXT)")
            .execute(&mut replica)
            .unwrap();
        sql_query("INSERT INTO test (id, val) VALUES (1, 'original')")
            .execute(&mut replica)
            .unwrap();

        replica
            .apply_patchset(&patchset, |_| ConflictAction::Abort)
            .unwrap();

        let val: String =
            diesel::dsl::sql::<diesel::sql_types::Text>("SELECT val FROM test WHERE id = 1")
                .get_result(&mut replica)
                .unwrap();
        assert_eq!(val, "updated");
    }

    #[test]
    fn test_delete_tracking() {
        let mut conn = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, val TEXT)")
            .execute(&mut conn)
            .unwrap();
        sql_query("INSERT INTO test (id, val) VALUES (1, 'to_delete')")
            .execute(&mut conn)
            .unwrap();

        let mut session = conn.create_session().unwrap();
        session.attach_by_name("test").unwrap();

        sql_query("DELETE FROM test WHERE id = 1")
            .execute(&mut conn)
            .unwrap();

        assert!(!session.is_empty());

        let patchset = session.patchset().unwrap();

        // Apply to replica with the row
        let mut replica = SqliteConnection::establish(":memory:").unwrap();
        sql_query("CREATE TABLE test (id INTEGER PRIMARY KEY, val TEXT)")
            .execute(&mut replica)
            .unwrap();
        sql_query("INSERT INTO test (id, val) VALUES (1, 'to_delete')")
            .execute(&mut replica)
            .unwrap();

        replica
            .apply_patchset(&patchset, |_| ConflictAction::Abort)
            .unwrap();

        let count: i64 = diesel::dsl::sql::<diesel::sql_types::BigInt>("SELECT COUNT(*) FROM test")
            .get_result(&mut replica)
            .unwrap();
        assert_eq!(count, 0);
    }
}
